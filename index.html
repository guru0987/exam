<html>
  <body>
     1. fork()
 #include <stdio.h>
 #include <unistd.h>
 #include <sys/types.h>
 int main() {
    pid_t pid;
    printf("Before fork: This is the original process.\n");
    pid = fork();
    if (pid < 0) {
        fprintf(stderr, "Fork failed\n");
        return 1;
    } else if (pid == 0) {
        printf("Child process: My PID is %d, My parent's PID is %d\n", getpid(), getppid());
    } else {
        printf("Parent process: My PID is %d, My child's PID is %d\n", getpid(), pid);
    }
    printf("After fork: This message is printed by both processes.\n");
    return 0;
 }
 2. creat()
 #include <fcntl.h>
 #include <unistd.h>
 #include <stdio.h>
 int main() {
    const char *filename = "LIONEL.txt";
    mode_t permissions = 0644;
    int fd = creat(filename, permissions);
    if (fd == -1) {
        perror("Error creating file");
        return 1;
    } else {
        printf("File '%s' created successfully with file descriptor %d\n", filename, fd);
        if (close(fd) == -1) {
            perror("Error closing file");
            return 1;
        }
        printf("File created successfully.\n");
    }
    return 0;
 }
 3. read()
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <fcntl.h>
 int main() {
    int fd;
    char buffer[1024];
    ssize_t bytes_read;
    const char *filename = "LIONEL.txt";
    fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd == -1) {
        perror("Error creating file");
        return 1;
    }
    write(fd, "Hello, read system call example!", 32);
    close(fd);
    fd = open(filename, O_RDONLY);
    if (fd == -1) {
        perror("Error opening file");
        return 1;
    }
    bytes_read = read(fd, buffer, sizeof(buffer) - 1);
    if (bytes_read == -1) {
        perror("Error reading file");
        close(fd);
        return 1;
    }
    buffer[bytes_read] = '\0';
    printf("Read %zd bytes: %s\n", bytes_read, buffer);
    if (close(fd) == -1) {
        perror("Error closing file");
        return 1;
    }
    return 0;
 }
 4. write()
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
 int main() {
    int fd;
    const char *message = "Hello, System Calls!\n";
    ssize_t bytes_written;
    fd = open("output.txt", O_CREAT | O_WRONLY, 0644);
    if (fd == -1) {
        perror("Error opening file");
        return 1;
    }
    bytes_written = write(fd, message, 21);
    if (bytes_written == -1) {
        perror("Error writing to file");
        close(fd);
        return 1;
    } else if (bytes_written < 21) {
        fprintf(stderr, "Warning: Not all bytes were written.\n");
    }
    if (close(fd) == -1) {
        perror("Error closing file");
        return 1;
    }
    printf("Message successfully written to output.txt\n");
    return 0;
 }
 5. open()
 #include <fcntl.h>
 #include <stdio.h>
 #include <unistd.h>
 int main() {
    const char* filename = "LIONEL.txt";
    int fd;
    fd = open(filename, O_RDONLY);
    if (fd == -1) {
        perror("Error opening file for reading");
        return 1;
    }
    printf("File '%s' opened successfully with file descriptor %d\n", filename, fd);
    if (close(fd) == -1) {
        perror("Error closing file");
        return 1;
    }
    fd = open("adhi.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("Error creating/opening adhi.txt for writing");
        return 1;
    }
    close(fd);
    return 0;
 }
 6. exec()
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
 int main() {
    char *args[] = {"ls", "-l", NULL};
    printf("Executing 'ls -l' using execvp...\n");
    execvp("ls", args);
    perror("execvp failed");
    return EXIT_FAILURE;
 }
 7. wait()
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <sys/wait.h>
 int main() {
    pid_t pid;
    printf("Parent process (PID: %d) is starting.\n", getpid());
    pid = fork();
    if (pid < 0) {
        perror("fork failed");
        exit(EXIT_FAILURE);
    } else if (pid == 0) {
        printf("Child process (PID: %d) created, parent PID: %d.\n", getpid(), getppid());
        sleep(2);
        printf("Child process (PID: %d) is exiting.\n", getpid());
        exit(EXIT_SUCCESS);
    } else {
        int status;
        printf("Parent process (PID: %d) is waiting for child (PID: %d).\n", getpid(), pid);
        wait(&status);
        printf("Parent process detected child (PID: %d) terminated.\n", pid);
        if (WIFEXITED(status)) {
            printf("Child exited with status: %d\n", WEXITSTATUS(status));
        } else {
            printf("Child terminated abnormally.\n");
        }
        printf("Parent process (PID: %d) is exiting.\n", getpid());
    }
    return 0;
 }
 8. exit()
 #include <stdlib.h>
 #include <stdio.h>
 int main() {
    printf("program exited\n");
    exit(0);
    // This line will never be reached
    return 0;
 }
 9. close()
 #include <stdio.h>
 #include <fcntl.h>
 #include <unistd.h>
 int main() {
    int fd = open("sample.txt", O_CREAT | O_WRONLY, 0644);
    if (fd == -1) {
        perror("Error opening file");
        return 1;
    }
    printf("File opened with descriptor %d\n", fd);
    if (close(fd) == -1) {
        perror("Error closing file");
        return 1;
    }
    printf("File closed successfully.\n");
    return 0;
 }
 10. getpid()
 #include <stdio.h>
 #include <unistd.h>
 int main() {
    printf("The process ID is: %d\n", getpid());
    printf("The parent process ID is: %d\n", getppid());
    return 0;
 
  </body>
</html>
